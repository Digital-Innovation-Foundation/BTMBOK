<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmi:id="-8JGLmsF2LASBynFkHXFPtw" name="integration_agile,_Zy7McDEBEeqUqvGmwOpKGQ" guid="-8JGLmsF2LASBynFkHXFPtw" changeDate="2020-01-07T14:57:24.688-0500">
  <mainDescription>&lt;h5>&#xD;
    From Early Agile to Integration Agile&#xD;
&lt;/h5>&#xD;
&lt;p align=&quot;justify&quot;>&#xD;
    Most organizations have an active effort to move to the right in the maturity model and fulfill consumer demand and&#xD;
    stay on top of the competition. Best practices and the guidelines provided in this section helps the organizations to&#xD;
    move right in the maturity model regardless of the current maturity level.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img alt=&quot;&quot; src=&quot;./resources/IA.png&quot; width=&quot;500&quot; height=&quot;300&quot; />&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    Figure 1. Early Agile stage&amp;nbsp;to Integration Agile stage&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;justify&quot;>&#xD;
    &lt;strong>People&lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;div align=&quot;justify&quot;>&#xD;
            Agile-core&#xD;
        &lt;/div>&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p align=&quot;justify&quot;>&#xD;
    Because being iterative is fundamental to an integration-agile organization, culture transformation must also be&#xD;
    handled iteratively. Forming a small group which we call the Agile-core is the first step in this process. The&#xD;
    agile-core team is a critical success factor in the entire transformation journey of an organization. Therefore be&#xD;
    mindful when picking people for this team. There are three rules to follow. First, pick the handful of people who&#xD;
    accept change and adapt quickly. Secondly, pick the people who have the required skill set or can easily be trained.&#xD;
    The third is to pick a diverse set of people who represent different levels and roles. The idea here to follow the&#xD;
    train the trainer and let the agile-core to train others and transform the entire organization into an agile, digital&#xD;
    workforce. Many approaches can taken in this transformation activity, such as structured training, boot camps,&#xD;
    hackathons, lunch-and-learn sessions, and innovation labs.&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;div align=&quot;justify&quot;>&#xD;
            Self-Organized teams&#xD;
        &lt;/div>&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p align=&quot;justify&quot;>&#xD;
    We noticed distributed teams with parallel running projects in the early maturity stages. However, distributed teams&#xD;
    depend on various Centers of Excellence (CoE) when it comes to end-to-end delivery of a project. The motivation behind&#xD;
    self-organized teams is to have a proper decentralized structure. A podular organizational structure provides the&#xD;
    platform for creating self-organized teams and operating successfully. Self-organized teams plan, build, run and manage&#xD;
    their applications independently. At the same time, the business functionality owned is exposed by using endpoints&#xD;
    which expose data as APIs, events, and streams.&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;div align=&quot;justify&quot;>&#xD;
            Everyone is an Agile Master&#xD;
        &lt;/div>&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p align=&quot;justify&quot;>&#xD;
    Most agile methodologies encourage having an agile master for each agile team. However, self-organized teams operate&#xD;
    differently. Team members are engaged, empowered and entrusted to implement innovative ideas and deliver as digital&#xD;
    products to end-users. Therefore every team member acts as an agile master in different stages and areas of the&#xD;
    project, regardless of any hierarchical levels assigned by the organization.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;justify&quot;>&#xD;
    &lt;strong>Process&lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;div align=&quot;justify&quot;>&#xD;
            Iterative&#xD;
        &lt;/div>&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p align=&quot;justify&quot;>&#xD;
    An integration agile organization uses an iterative execution model in business and technical processes. It is easy to&#xD;
    define iterative processes but hard to execute without a conventional culture and architecture. The sub-topics we&#xD;
    discuss under Organization &amp;amp; Culture are vital to creating a supportive culture. Fundamentals of the iterative&#xD;
    approach are about starting small while having a bigger vision and continuously iterating towards the target. Planning&#xD;
    iterations that range between one month to three months is effective.&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;div align=&quot;justify&quot;>&#xD;
            Continuous (Agile + DevOps)&#xD;
        &lt;/div>&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p align=&quot;justify&quot;>&#xD;
    The continuous process we describe in this document is a combination of agility and enhanced DevOps, which is part of&#xD;
    development and utilizes cloud-native infrastructure. The combination of DevOps and development enables an end-to-end&#xD;
    automated continuous process. This approach streamlines the release process and increases development teamsâ€™&#xD;
    productivity.&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;div align=&quot;justify&quot;>&#xD;
            Code over Configuration&#xD;
        &lt;/div>&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p align=&quot;justify&quot;>&#xD;
    A configuration-based approach, coupled with the utilization of heavy middleware layers, is the primary blocker that&#xD;
    prevents development teams from operating in a real agile mode. It is difficult to link configuration-driven&#xD;
    development models with a continuous release pipeline and fully automated application lifecycle with multiple lifecycle&#xD;
    stages (environments). Additionally, most of the middleware runtimes are not microservices and cloud-native friendly.&#xD;
    As a solution, a coding-based approach that uses a programing language optimized for integration will allow teams to&#xD;
    meet the expected agility and compliance with a continuous pipeline.&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;div align=&quot;justify&quot;>&#xD;
            Integration First&#xD;
        &lt;/div>&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p align=&quot;justify&quot;>&#xD;
    The programming model has changed during the last decade to an integration-first approach. This is mainly due to the&#xD;
    programmable and reusable endpoints that enterprises have created using various distributed architecture patterns, such&#xD;
    as service-oriented architecture (SOA), event-driven architecture (EDA), and microservices architecture (MSA). As a&#xD;
    result, every programmer is an integration engineer today. Moreover, the modern enterprise architecture is integration&#xD;
    driven, with apps and services that each have tens to hundreds of composable endpoints.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;justify&quot;>&#xD;
    &lt;strong>Technology&lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;div align=&quot;justify&quot;>&#xD;
            Pipeline tuned&#xD;
        &lt;/div>&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p align=&quot;justify&quot;>&#xD;
    Developers spend much time building their sandbox environments and linking them to the source control system and build&#xD;
    pipeline. Sometimes they do not follow standards due to manual configuration and linking. The concept of a pipeline&#xD;
    ready is a solution for that which provides the sandbox environment and links to the development tools in a fraction of&#xD;
    time using an automated process. Pipeline readiness increases the productivity of developers and enforces governance&#xD;
    and development standards. Additionally, it makes the developers own most of the DevOps responsibilities from day-1 and&#xD;
    maintain project specific CI/CD pipelines.&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;div align=&quot;justify&quot;>&#xD;
            Multi environment based application lifecycle&#xD;
        &lt;/div>&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p align=&quot;justify&quot;>&#xD;
    The traditional development and deployment lifecycle of an application build is based on a minimum of three&#xD;
    environments: development, testing and production. Some organizations have added a staging environment as a safe site&#xD;
    to debug production issues. However, the iterative and rapid release nature of the self-organized team requires the&#xD;
    addition of more environments to be productive, as well as have an infrastructure, CI/CD pipeline, and DevOps practice&#xD;
    support. We are looking at adding blue-green, canary, and automated A/B testing environments to the application&#xD;
    lifecycle.&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;div align=&quot;justify&quot;>&#xD;
            Test driven development&#xD;
        &lt;/div>&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p align=&quot;justify&quot;>&#xD;
    Traditionally testing of an application is a secondary action executed by a separate group by creating another silo or&#xD;
    a CoE. In an integration agile environment, the project team itself is responsible for delivering a high-quality&#xD;
    application. (Remember, project teams plan, build, run and manage the application.) Therefore testing is part of the&#xD;
    project team, which is executed by the developers. Automated tests (unit, performance, and integration) with test data&#xD;
    and test systems (e.g., mock services) have to be created before the development and automated tests run against the&#xD;
    code from day-one. Developers are required to enrich the test framework by introducing many test scenarios based on&#xD;
    various business and technical use-cases (functional and non-functional). Some organizations call it the test grid,&#xD;
    which strengthens the quality of the application.&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;div align=&quot;justify&quot;>&#xD;
            Cloud-native&#xD;
        &lt;/div>&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p align=&quot;justify&quot;>&#xD;
    The heavily decentralized nature of a self-organized team and distributed DevOps responsibilities require a proper&#xD;
    infrastructure to support integration-agile organizations. A cloud-native architecture based on containers and&#xD;
    container orchestration systems helps development teams to utilize a company-wide standardized infrastructure to deploy&#xD;
    and run applications and any dependencies. Using containers to autoscale, package applications, tune the pipeline, and&#xD;
    support CI/CD by rapid environment provisioning are a few basic cloud-native capabilities that can be utilized by&#xD;
    self-organized teams. Also, advanced features like event-driven and function-based architectures can utilize a&#xD;
    cloud-native infrastructure to enhance the overall integration agility.&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;div align=&quot;justify&quot;>&#xD;
            Cell-based architecture&#xD;
        &lt;/div>&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p align=&quot;justify&quot;>&#xD;
    Emerging architectural patterns, such as layered and segmented architectures, are centralized or depend on centralized&#xD;
    CoEs. On the other hand, microservices defined in a microservice architecture (MSA) are too granular to treat as an&#xD;
    architecture unit. Hence, self-controlled teams require a reference architecture to define the logical and physical&#xD;
    architecture boundaries in the enterprise as a whole.&lt;br />&#xD;
    We introduced the cell-based reference architecture as a solution for this problem to have a microservice and&#xD;
    cloud-native architecture leading enterprise architecture to utilize in an integration-agile environment. The&#xD;
    cell-based architecture enables the conversion of legacy systems, services, and data into cells, and it reuses the&#xD;
    functionality in combination with the cloud-native cells. In a nutshell, the cell-based architecture makes it possible&#xD;
    to build on brownfield development.&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;div align=&quot;justify&quot;>&#xD;
            Open source&#xD;
        &lt;/div>&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p align=&quot;justify&quot;>&#xD;
    In an integration-agile environment, you expect to do many innovations in labs (note that research and development is&#xD;
    part of the self-organized teams), as well as rapid application development by following iterative execution model. In&#xD;
    such an environment, you cannot afford to wait for lengthy (and slow) procurement processes to adopt the technologies&#xD;
    that will allow you to deliver on your innovative ideas. Open source plays a significant role here by giving you access&#xD;
    to robust and stable technologies that are used and contributed by a broader community. You can pick technologies&#xD;
    delivered under business-friendly open source licenses, such as Apache 2.0, to avoid any corporate red lines in the&#xD;
    future.&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;justify&quot;>&#xD;
    &lt;strong>Digital Alignment&lt;/strong>&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;div align=&quot;justify&quot;>&#xD;
            Consumer-driven requirements&#xD;
        &lt;/div>&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p align=&quot;justify&quot;>&#xD;
    One of the critical characteristics of a podular architecture is bringing self-organized development teams to the edge&#xD;
    of the business and providing access to consumers. Minimizing the gap between the consumer and the producer helps to&#xD;
    implement solutions that are actually required by the consumers without working on hypothetical requirements that&#xD;
    trickle down through many CoEs. The development teams can have a direct dialog with the consumers using various&#xD;
    channels, analyze consumer behavior, and review the market outlook when identifying and prioritizing business&#xD;
    requirements. Small iterations and rapid application development help self-organized teams to deliver a feature quickly&#xD;
    and test run it with the actual consumers (including the rollback of a feature). Technical teams tend to complicate the&#xD;
    requirements by looking at it from a technical point of view. In an integration-agile environment the requirements&#xD;
    teams look at are from the consumer (or business) point of view and simply based on the consumer experience and&#xD;
    competitive advantage.&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;div align=&quot;justify&quot;>&#xD;
            Start with a MVP&#xD;
        &lt;/div>&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p align=&quot;justify&quot;>&#xD;
    The consumer-driven nature and business first culture result in rapid changes to the requirements and the user&#xD;
    experience. Consumers are eager to consume new digital experiences and make themselves productive during day-to-day&#xD;
    activities. Once they don't get the experience they are looking for, they switch the service providers. Also, there is&#xD;
    a competitive advantage in introducing a new idea to the market before competitors provide the same. Planning,&#xD;
    implementing and launching a minimal viable product (MVP) to the market is the best way to stick to the iterative&#xD;
    execution model, rather than having long product delivery cycles that follow waterfall or fast-waterfall methodologies.&#xD;
    Self-organized teams get the foundation and platform by staying at the edge, close to consumers to understand them&#xD;
    correctly and define the MVP.&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;div align=&quot;justify&quot;>&#xD;
            Deliver digital-native applications&#xD;
        &lt;/div>&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p align=&quot;justify&quot;>&#xD;
    As we explained earlier in this paper, consumers in the modern digital era come with certain predefined expectations.&#xD;
    To reemphasize the current digital expectations, these include real-time, personalized, geo-sensitive and predictable&#xD;
    experiences from digital applications. Disruptive applications released from the self-organized teams have to be&#xD;
    digital-native to win the market and provide long-term services for the consumers.&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &lt;div align=&quot;justify&quot;>&#xD;
            Enforce feedback loops&#xD;
        &lt;/div>&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p align=&quot;justify&quot;>&#xD;
    A useful iterative execution model requires feedback coming from usage and runtime behavior. A cell-based architecture&#xD;
    enforces the cell gateways to route communications and provide enough hooks to capture the data required to identify&#xD;
    feedback about usage and the behavior of runtimes. Constructive feedback has to be considered when planning the next&#xD;
    iteration in order to improve the user experience and runtime behavior.&lt;br />&#xD;
&lt;/p></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
